package com.justbon.scala

abstract class  Tree {
  /*****
    * 我们实际上定义了三个条件类 Sum ,Var 和 Const 。这些类和普通类有若干不同：
    * 　　1. 实例化时可以省略new关键字（例如你可以使用 Const(5)而不必使用 new Const(5) ）
    * 　　2. 参数的getter函数自动定义（例如你可以通过c.v来访问类Const的实例c在实例化时获取的参数v）
    * 　　3. 拥有默认的预定义equals和hashCode实现，这些实现可以按照值区别类实例是否相等，而不是通过用。
    * 　　4. 拥有默认的toString实现。这些实现返回值的代码实现（例如表达式x+1可以被表达成Sum(Var(x),Const(1))）
    * 　　5. 条件类的实例可以通过模式匹配进行分析，我们接下来就要讲这个特性
    */
  case class Sum(l: Tree, r: Tree) extends Tree
  case class Var(n: String) extends Tree
  case class Const(v: Int) extends Tree
  type Environment = String => Int //从现在开始，类型Environment就当作String到Int的函数类型名来使用了。

  def eval(t: Tree, env: Environment): Int = t match {
    /****
      * 1. 第一个模式检查传入的树的根节点是否是一个Sum,
      * 如果是,它将会吧树的左边子树赋值给l,右边的子树赋值给r,
      * 然后按照箭头后面的代码进行处理;这里的代码可以（并且的确）
      * 使用了在左边匹配时所绑定的变量,比如这里的l和r.
      */
    case Sum(l, r) => eval(l, env) + eval(r, env)

    /*****
      * 2. 如果第一个检查没有成功,表明传入的树不是Sum,程序继续检查他是不是一个Var;如果是,则吧变量名赋给n然后继续右边的操作
      */
    case Var(n)    => env(n)

    /****
      * 3. 如果第二个检查也失败了,表示t既不是Sum也不是Var,程序检查他是不是Const。如果是 赋值变量并且继续。
      */
    case Const(v)  => v

    /****
      * 4. 最后，如果所有检查都失败了。就抛出一个异常表示模式匹配失败。这只有在Tree的其他之类被定义时才可能发生。
      */
  }
  //求值函数通过对树t进行模式匹配来完成工作。直观的来看，上述代码的思路是十分清晰的：
  /****
    * 我们可以看出模式匹配的基本思想就是试图对一个值进行多种模式的匹配,
    * 并且在匹配的同时将匹配值拆分成若干子项，最后对匹配值与其子项执行某些代码.
    */
}
/***
  * 　　一个熟练的面向对象的程序员可能想知道为什么我们不吧eval定义为Tree或者其之类的成员函数。
  * 我们事实上可以这么做。因为Scala允许条件类象普通类那样定义成员。
  * 决定是否使用模式匹配或者成员函数取决于程序员的喜好，不过这个取舍还和可扩展性有重要联系：
  * 　　1. 当你使用成员函数时，你可以通过继承Tree从而很容易的添加新的节点类型，但是另外一方面，
  * 添加新的操作也是很繁杂的工作，因为你不得不修改Tree的所有子类。
  * 　　2. 当你使用模式匹配是，形势正好逆转过来，添加新的节点类型要求你修改所有的对树使用模式匹配的函数，
  * 但是另一方面，添加一个新的操作只需要再添加一个模式匹配函数就可以了。
  * */
